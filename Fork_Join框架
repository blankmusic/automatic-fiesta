Fork/Join框架：
是javav7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干
小任务，最终汇总每个小任务结果后得到大任务结果的框架。
工作窃取算法（working-stealing）：
是指某个线程从其他队列里窃取任务来执行。
为什么需要使用工作窃取算法呢，假如我们需要做一个比较大的任务，我们可以把这个任务分割成若干个互不依赖的子任务，为了
减少线程间的竞争，于是把这些子任务分别放到不同的队列，并为每个队列创建一个单独的线程的来执行队列里的任务，线程和队列
一一对应。如A线程负责独立A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他的线程对应的队列里还有任务等待处理。
干完活的线程就去其他线程的队列里窃取一个任务来执行，
而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被求取任务线程之间的竞争，通常会使用双端队列，被窃取任务的线程永远从双端队列的
头部拿任务，而窃取任务的线程永远从双端队列的尾部拿任务。
工作窃取算法的优点：
充分利用线程进行并行计算，并减少了线程之间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列中只有一个任务时。并且消耗了更多的系统资源
，比如创建多个线程和多个双端队列。
Fork/Join实现原理：
第一步：分割任务， 首先我们需要一个fork类来吧大任务分割成子任务，有可能子任务还是很大，所以要不停的分割，直到分割的子任务足够小。
第二步：执行任务合并结果。
分割的任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都同意放在一个队列里，启动一个线程从队列里拿
数据，然后合并这些数据。
第三步：再启动一个线程合并结果队列的值。

Fork/Join使用两个雷来完成以上两个事情：
ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务重执行fork()和join()操作的机制，通常情况下，我们不需要
直接继承ForkJoinTask类，儿只需要继承它的紫烈，fork/1kuangjia提供了一下两个子类：
       RecursiveAction:用于没有返回结果的任务
       RecursiveTask:用于有返回结果的任务，
       ForkJoinPool:ForkJoinTask需要通过ForkJoinPool来执行，任务分割出子任务会添加到当前线程所维护的双端队列中，进入队列的头部。当一个工作线程
       的队列里暂时没有任务是，他会随机从其他工作线程的队列的尾部获取一个任务。
       
       
       
       

