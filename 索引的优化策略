1 最左前缀匹配原则
2 主键外键一定要建立索引
3 对where ，on ，group by，order by中出现的列使用索引
4 尽量使用区分度高的列作为索引，区分度的公式是count(distinct col)/count(*),表示字段的不重复比例。
比例越大我们扫描的记录数越少，唯一键的区分度1，而一些状态，性别字段可能在大数据面前区分度是0；
5 对较小的数据列使用索引，这样会使索引文件更小，同时内存中也可以装载更多的索引键。
6 索引列不能参与计算，保持列“干净”，比如 from_unixtime(create_time)='2014-05-29'就不能使用索引，原因很简单，
b+树中存在的都是数据表中的字段值，进行检索时，需要把所有的元素都应用到函数才能比较，显然成本太大。所以语句应该写成
create_time=unix_timestamp('2014-05-29');
7 为较长的字符串使用前缀索引
8 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
9 不要过多的创建索引，权衡索引数量和DML之间的关系。DML也就是插入，删除数据操作。这里需要权衡一个问题，建立索引的目的是为了
提高查询的效率，但建立的索引过多，会影响插入和删除数据的速度，因为我们修改的表数据，索引也需要进行调整重建。
10 对于like查询“%”不要放在前面
SELCT*FROM huahua WHERE LIKE‘后盾%’--走索引
SELECT*FROM huahua WHERE LIKE ‘%后盾%’--不走索引
11 查询where条件数据类型不匹配的时候也无法使用索引
字符串与数字不匹配 不走索引
CREATE TABLE a(a char(10));
EXPLAIN SELECT *FROM a WHERE a="1"--走索引
EXPLAN SELEECT **FROM a WHERE a=1;--不走索引

12 正则表达式不使用索引，这应该很好理解，所以为什么SQL中很难看到regxp关键字的原因
