java的内存模型是围绕着并发的原子性，有序性和可见性来创建的。
read  ：把一个变量的值从主内存传输到工作内存
load： 在read之后进行，吧read的值放入工作内容的变量副本中
use： 把工作内存的一个变量传递给执行引擎
assign：把一个执行引擎接收到的值赋值给工作内存中的变量
store： 把工作内存的一个变量的值传送给主内存
write：在store之后进行，将store获得的值放入主内存的变量中
lock 作用于主内存的变量
unlock



原子性（Atomicity）
基本的数据类型的读写是具有原子性的。如果应用场景需要一个更大的方位保证原子性，java内存模型还提供了lock和unlck操作来满足这一需求。
虚拟机没有吧lock和unlock直接开放给用户使用，但是提供了更高层次的字节码指令monitorenter和monitorexit莱茵石的使用这两个操作，这两个字节指令反映到
java中就是同步块synchronized关键字。因此synchronized块之间的操作也具有原子性。

可见性（Visibility）
可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。java内存模型是通过在变量修改后将新值同步到主内存中，在变量读取前从之内存中
刷新便令值这种依赖主内存作为传递媒介的方式来实现可见性的。无论是volatile关键修饰的变量还是普通变量都是如此。不过volatile的特殊规则保证了新值能
立即刷新到主内存中。volatile可以保证多线程操作时变量的可见性。
此外还有两个关键字能够保证可见性synchronized和final。  synchronized同步块的可见性是有synchronized的“对一个变量执行unlock之前必须把字段变量同步
到主内存中”来实现的。而final关键字的可见性是指；被final修饰的变量一旦在构造器中初始化完成，并且构造器没有吧this这个引用传递出去，那么其他线程就可
看见final关键字段的值。
volatile synchronized final



有序性（Odering）
有序性是指在本线程内观察，所有的操作都是有序的。在一个线程观察另一个线程，所有的操作都是无需的，这是因为发生了指令重排。
java语言提供；额volatile和synchronized关键字来保证线程之间的有序性。
在java内存模型中允许编译器来处理器对指令进行重排，重排序不会影响单个线程的执行，但是会影响多线程并发执行的正确性。volatile通过添加内存品章来禁止
指令重排，即重新排序时不能把后面的指令放在内存屏障之前。也可一通过synchronized的关键字来保证有序性。他保证每个时刻只有一个线程执行同步代码，相当于
让线程顺序执行代码。
