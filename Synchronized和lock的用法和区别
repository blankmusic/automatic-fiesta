1 lock是一个接口，而synchronized是一个关键字，是内置的语言实现。
2 synchronized在发生异常的时候，会自动释放线程所占有的锁，因此不会导致死锁的发声；
  而lock在发生异常的时候，如果没有主动通过unlock（）去释放锁，则很可能造成死锁现象，因此在使用lock是需要在finally块中释放锁。
3 lock可以让等待锁的线程响应中断（可中断锁），而synchronized不能响应中断，使用synchronized时，使用的线程可能会一直等待下去，
  不能够响应中断（不可中断锁）。
4 通过lock可以知道有没有成功获得锁（tryLock（）方法：如果获取了锁，则返回true，否则false，也就是这个方法无论如何都会立即返回。 
  在拿不到锁的时候不会一直等待）而synchronized则无法办到。
5 lock可以提高多个线程进行读操作的效率（读写锁）
6 Lock可以实现公平锁，synchronized不保证公平性。

在性能来说，如果线程竞争资源不激烈时，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量的线程同时竞争），此时Lock的性能要
远远由于synchronized。所以说，在具体使用时要根据适当的情况选择。
