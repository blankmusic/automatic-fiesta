java内存模型

JMM试图屏蔽各种硬件和操作系统的内存访问差异，已实现就java程序在任何平台上都能达到一致的内存访问效果。处理器上的寄存器的速度比内存
快几个数量级，为了解决速度矛盾，在它们之间加入高速缓存区。高速缓存带来一个新的问题。如果多个高速缓存共享同一块主内存区域，那么多个
缓存数据之间的数据可能会不一致。解决方案：所有的数据都存储在主内存中，每个线程还有自己的工作内存存储在高速缓存区或者寄存器中，保存
了该线程使用的变量的主内存副本拷贝。线程只能直接操作工作内存中的变量，不同线程之间的变量传递需要通过主内存来完成。

Java线程之间的通信采用的是过共享内存模型，这里提到的共享内存模型指的就是Java内存模型(简称JMM)，JMM决定一个线程对共享变量的写入何时对另一个线程可见。
从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory）
，本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

先行发生原则（happens-before）是jmm的最核心的概念
1 线程内的代码能够按照先后顺序执行，程序次序顺序。
2 有一个unlock操作先行发生于后面对同一个锁的lock操作 ，管程锁定规则
3 对一个volatile变量的写操作先行发生于后面对这个变量的读操作，volatile变量规则
4 一个线程的任何操作必须在start（）调用用之后 线程启动原则
5 一个线程的所有操作都会在线程终止之前，线程终止规则
6 一个对象的终结操作必须在这个对象构造完成之后，也叫对象终结规则
7 可传递性
