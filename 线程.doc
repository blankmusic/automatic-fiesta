Volatile关键字
一单一个共享的变量 类的成员变量或者类的静态成员变量 背volatile修饰之后 那么就具备了两层含义

1 保证了不同线程对这个变量的可见性 即一个线程改变了某个变量的值 这个新值对其他线程是立即可见的
2 禁止指令重排
volatile 保证了 有序性 可见性


可见性： 所有的变量都存储在主内存中，每个线程有自己的工作内存，工作内存存储在高速缓存区或者寄存器中。
保存了该线程使用的变量的主内存的副本拷贝。线程只能直接操作工作区内存中的变量，不同线程之间进行变量值
传递只能通过主内存来完成。
    
   线程不直接和主内存进行数据交互，而是通过线程的工作内存来进行这一工作，这也是线程间的数据不可见的本质原因，
   因此要实现volatile关键字的可见性要实现以下两点
    1 被volatile关键字修饰的变量被修改时，会强制刷新主内存中的值
    2 修改volatile关键字修饰的变量后 会导致其他线程内的对应变量值失效，因此再读取该变量的值得时候要从主内存中读取值。
    
    
有序性： 内存屏障 内volatile修饰关键字，在赋值之后会执行“load addl $0x0, (%esp)”操作这个操作 相当于一个内存屏障
（指令重排序是不能把后面的指令重排序内存屏障之前的位置），只有一个cpu访问内存时不粗要内存屏障（什么是指令重排：是指cpu采用允许
将多条指令不按照程序规定的顺序分开发送给各相应的电路单元处理），volatile会出发jvm的内存屏障侧罗，内存屏障保证有序性jvm有4种内存屏障。
   简单来说，volatile会在一定程度上影响jvm指令集的优化策略，在volatile之前和之后的指令集不会乱序越过volatile变量执行




synchronized 关键字解析
    Synchronized 修饰方法和代码块以及类。
    是一种可重入锁，可以保证方法或者代码块在运行时，同一时刻只有一个线程可以进入到临界区（互斥性），同时保证共享变量的内存可见性。
    java中的每个对象都可以作为锁，synchronized的四种应用方式
    普通同步方法：锁是当前实例对象
    静态同步方法：锁是当前类的class对象
    同步代码块：锁是括号中的对象
    同步类：作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。
synchronized可重入性
    从互斥锁的设计上来说，当一个线程试图操作一个有其他线程持有的对象锁的临界资源时，将会处于阻塞状态，
    但当一个线程再次请求自己持有的对象锁的临界资源时，这种情况属于重入锁，请求将会成功。
    在java中，synchrod是基于原子性的内部锁机制，是可重入的。因此，在一个线程调用synchronized方法的同时，
    在其他方法体内部调用该对象的另一个synchronized方法，也就是说一个线程得到一个资源后再次请求该对象锁，是允许的。
    这就是synchronized的可重入性。另外，当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。
中断与synchronized
    事实上，线程的中断操作对于正在等待获取的锁对象的synchronized方法或代码块是不起作用的，也就是对于synchronized来说，
    如果一个线程在等待锁，那么结果就只有两种，要么获得这把锁继续执行，要么就保存等待，即使调用中断线程的方法，也不会生效。
等待唤醒机制与synchronized
    这次所指的等待唤醒机制，是notify/notifyAll和wait方法，在使用这三种方法的时候，必须处于synchronized代码块，或者synchronized方法中。
    否则就会抛出 IlligalMonitorStateException异常，这是因为 调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说，
    notify/notifyAll和wait方法依赖于monitor对象，在前面的分析中，我们知道monitor、对象存在于对象头的Markword
    中（存储monitor引用指针），而synchronized关键字可以获取monitor，这也就是为什么这三种方法必须在synchronized代码块或者
    synchronized方法调用的原因。
synchronized的底层语义原理
    java虚拟机中的同步synchronized基于进入和退出管理Monitor对象实现，
    无论是显示同步（有明确的的monitorentre和monitorexit指令，即代码同步块） 还是隐式同步都是如此。
    在java中同步被用到的最多的就是synchronized关键字修饰的同步方法。
    同步方法并不是由monitorentre 和monitorexit指令来实现同步的，而是由方法调用指令读取运行时常量池中的方法的ACC_SYNCHRONIZED标志来
    隐式实现的。
    代码同步块 是有monitorentre和monitorexit指令来实现同步的，在jvm中，对象在内存中的布局分为三块区域，对象头，实例数据，对齐填充。
    
    
    
    
    
    
    
