死锁
死锁是指两个或者两个以上的进程（或线程）在执行的过程中，争夺资源而造成的的一种互相等待的现象。
若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或者产生了死锁。这些永远互相等待的
进程都称为死锁进程。

产生死锁的原因
1 系统资源不同
2 进程运行推进的顺序不当
3 资源分配不当


产生死锁的四个条件
1 互斥条件 ：所谓互斥条件就是进程在某一时间内独享资源。
2 请求与保持条件:一个进程因请求资源而阻塞，对已获得的资源保持不放。
3 不剥夺条件：进程已获得资源，在未使用完之前，不能强行剥夺。
4 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。


避免死锁
1 破坏互斥条件，使得资源不被一个进程独占，一般是不可能破坏的，在死锁里主要破坏其他三个条件。
2 破坏请求保持条件：在系统中允许在已获得资源的情况下，申请其他资源。即，要想出一个班达，阻止进程在持有资源的同时申请其他资源。
   破坏请求和保持法1--所有进程在运行之前都必须获得整个运行过程中所需的全部资源，这样就不用再提出请求了，只要有一种资源不满足，
   就不给进程分配资源。
   缺点：资源被严重浪费，严重恶化资源利用率
        使进程经常会发生解现象。
        法2--要求每个进程提出新的资源申请前，释放它所占有的资源。
3 破坏不可抢占条件：允许对资源进行抢占
         方法1 如果占有某些资源的一个进程进行进一步资源请求失败，则该进程必须释放它最初占有的资源，如果有必须要可以再次请求这些资源。
         方法2 如果一个进程请求另一进程占有的一个资源，则擦偶偶系统可以抢占另一个进程的机缘。再有在任意两个进程的优先级都不相同的情
         况下，该方法才能预防死锁。
4 破坏循环等待条件：将系统中所有资源进行统一的标号，进程可在任何时刻提出资源申请。但所申请的资源必须按照资源的标号的升序来提出。这样
  就能保证系统不出现死锁。(银行家算法、安全性算法)
  
  死锁的解除
  一旦检测出死锁，就应立即采取相应的措施，以解决死锁。死锁的解除主要有两种方法
  1 抢占资源    从一个或多个 进程中获得足够的资源，分配给死锁进程，以解除死锁的状态
  2 终止或撤销进程  终止或撤销系统中的一个或多个死锁进程，直至打破循环环路。使系统从死锁状态解脱出来。
  
  
  活锁：
  活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试。活锁通常发生在处理事务消息的应用程序中。
  如果不能成功处理事务那么事务将回滚整个操作。
  解决活锁的方法是在每次重复执行的时候引入随机机制，这样由于出现的可能性不停使得程序可以继续执行其他的任务。
  
  活锁的解决办法
  解决协同活锁的一种方案是调整重试机制。比如引入一些随机性。例如如果检测到冲突，那么就暂停随机的一段时间进行重试。这会大大减少碰撞的可能性。
  典型的例子就是以太网的CSMA/CD检测机制
  活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，，即所谓的‘活’，而处于死锁的实体则表现为等待；活锁有可能自行解开，死锁则不能。
  
  饥饿
  饥饿，一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。
  
  java中到导致饥饿的原因
  1 高优先级的线程吞噬所有的低优先级线程的CPU时间
  2 程被永久阻塞在一个等待进入同步块的状态，因为其他线程总是能在他之前持续的对该同步块进行访问。
  3 线程在等待一个本身也处于永久等待完成的对象（比如调用这个对象的wait（）方法），因为其他线程总是被持续的获得唤醒。
  
  
  解决饥饿的方案被称为‘公平性’--即所有的线程讷讷狗狗狗宁德获得运行的机会
  在java中实心公平性方案，需要：
  1 使用锁，而不是同步块
  2 公平锁
  3 注意性能方面
  
  
  
  
  
  
  
  
  
  
  
  
